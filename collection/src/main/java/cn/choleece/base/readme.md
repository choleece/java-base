## Java 面试知识点整理
1. https://github.com/crossoverJie/JCSprout/blob/master/README.md

2. https://crossoverjie.top/JCSprout/#/jvm/MemoryAllocation

## Java 基本类型占内存大小
1. 整型

| 类型 |  内存大小    | bit数 |
|------|:----------:|------:|
| byte |  1B        | 1 x 8bit |
| short|  2B        | 2 x 8bit |
| int  |  4B        | 4 x 8bit |
| long |  8B        | 8 x 8bit |

2. 浮点

| 类型 | 内存大小     | bit数
|------|:------------|:--------|
| float| 4B          | 4 x 8bit|
|double | 8B         | 8 x 8bit|

3. char类型

| 类型 | 内存大小     | bit数
|------|:------------|:--------|
| char | 2B          | 2 x 8bit|

4. boolean类型

| 类型 | 内存大小     | bit数
|------|:------------|:--------|
| boolean | 1B       | 1 x 8bit|

## 锁优化

锁优化：主要是互斥同步对性能最大对影响就是阻塞，挂起线程和恢复线程都需要转入内核状态完成，这些操作给系统的并发性能带来很大的压力，因此针对此问题给出了一些锁优化的方法
每一种方法并不是绝对的优化，主要针对某一类场景，锁最后会逐渐升级，但是不会降级

参考：深入理解Java虚拟机 周志明著 P397
     https://www.jianshu.com/p/a19c4e2ce65c
     
1. 自旋锁、适应性自旋锁、锁消除、锁粗化、轻量级锁、偏向锁

### 锁优化讲解：

1. 自旋锁（Spinning Lock，通过-XX:+UseSpinning 开启， JDK1.6 默认开启）：前边我们提到，互斥同步，会有挂起线程和恢复线程的大量开销，影响性能，经过实际观察，发现线程持有锁的时间都相对较短，所以有时候没有必要一发现互斥了，就阻塞，人间不值得。
所以会才有一种机制，就是"再看看"，最简单的补偿机制就是在原地自旋（就是循环），循环的去检查锁是否被释放，如果被释放，那么就直接获取锁，自旋锁在锁占用时间非常短的情况下效果非常好，但是如果锁占用时间比较长，
这样就会产生一个问题，比如持有锁的线程长期不释放锁，那么循环检查就要一直进行，这个循环也是有CPU开销的，所以这也是要考虑的点，平时我们在做重试机制也是，重试也是有限度的，自旋超过一定的限定次数仍然没有成功获得锁，就应当用传统的方式
去挂起锁，自旋次数默认是10，可以通过-XX:PreBlockSpin 来更改。

2. 适应性自旋锁（Adaptive Spinning Lock,通过）：前边我们提到，自旋锁的重试次数默认是10次，或者通过-XX:PreBlockSpin 来更改，也是一个固定的次数，而自适应性自旋锁意味着这个时间不固定，而是由上一次在同一个锁上的自旋时间及锁的拥有者状态决定。
比如在同一个锁对象上，自旋刚刚获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也很有可能成功，那么它的自旋次数会多一些，如果对于某个锁，自旋锁很少获得成功，那么可能自旋锁这个机制会直接省略掉，避免浪费处理器资源

3. 锁消除（Lock Elimination）: 锁消除是指在虚拟机即时编译运行时，针对一些代码上要求的同步，但是检测到堆上所有的数据不会逃逸到其他线程去从而造成共享，这时可以认为他们是线程私有的，同步锁自然无法进行，比如：
```
    public String concatString(String s1, String s2, Stirng s3) {
        StringBuffer sb = new StringBuffer();
        sb.append(s1);
        sb.append(s2);
        sb.append(s3);
        
        return sb.toString();
    }
```
我们去看源码就知道，StringBuffer的方法前边加了synchronized关键字,底层调用的是StringBuilder的append()，这里也顺便解释来StringBuffer为什么是线程安全的，StringBuilder不是线程安全的（这时题外话），经过虚拟机编译发现，sb 的所有引用
都不会逃逸到concatString的外边去，其他永远也不会访问到sb，所以，虽然这里加锁了，但是可以安全的被清除掉，这就是所谓的锁清除。

4. 锁粗化（Lock Coarsening）: 原则上，我们写代码，总是希望把锁定的范围限定小，只在尽可能小的范围内控制同步，但是有时候手动写的代码却不是，比如：
```
    Object obj = new Object();
    
    for(int i = 0; i < 100; i++) {
        synchronied(obj) {
            System.out.println("obj: " + obj.toString());   
        }
    }
```

这种情况就可以将锁粗化成：
```
    Object obj = new Object();
    synchronied(obj) {
        for(int i = 0; i < 100; i++) {
            System.out.println("obj: " + obj.toString());   
        }
    }
```

5. 轻量级锁（LightWight Locking）: 轻量级锁是针对传统的同步互斥的来说的。在HotSpot的虚拟机的对象头（Object Header）分为两部分信息，第一部分存储对象本身的运行数据，如（HashCode）,GC分代年龄（Generational GC Age）等，
这部分的数据长度在32位、64位长度的虚拟机中分别位32bit,64bit，官方成为"Mark Word"，这是实现轻量级锁 + 偏向锁的关键，第二部分用于执行方法区对象类型数据的指针，如果是数组对象的化，还会有一个额外的部分用于存储数组长度。
比如在32bit的mark word中，有最后2bit存储锁标志，4位存储对象分代（新生代【eden, survivor(survivor又分为from survivor, to survivor), 比例为8：1：1】，老年代），25bit存HashCode，1bit固定为0

    a. 加锁过程：
    1. 当代码进入同步块当时候，如果同步锁对象为无锁状态（锁标志位为01），虚拟机首先在当前线程当栈桢中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前Mark Word的拷贝
    2. 拷贝完成后，虚拟机采用CAS的方式，将对象的mark word（原来HashCode、GC分代、固定bit的位置） 更新为指向Lock Record的位置，并且将改"对象"的mark word的最后2bit的锁标记为00(表示处于轻量及锁)
    3. 如果更新失败，则查看下对象mark word指向**当前线程**Lock Record，如果是，那么说明改线程已经拥有该对象的锁，直接进入同步代码块继续执行，否则说明这个锁对象被其他线程抢占了。如果有两个以上的线程竞争同一锁，那轻量级锁将
       不再有效，要膨胀为重量级锁，锁标志的状态为"10", Mark Word中存储的就是指向重量级锁（互斥量）的指针，后面的等待锁线程也要进入阻塞状态
       
    b. 释放锁过程：
    1. 通过CAS 将Lock Record内容替换当前对象的Mark Word里的内容
    2. 如果替换成功，那么整个过程结束，锁释放成功
    3. 如果替换失败，说明其他线程尝试过获取该锁，那就要在释放锁的同时，需要**唤醒**（因为已经阻塞了）被挂起的线程。
    
轻量级锁能提升性能的依据是"对于绝大多部分的锁，在整个同步周期内不都是不存在竞争的"，这是一个经验数据。如果没有竞争，CAS避免了互斥的开销，如果存在竞争，那么除了有互斥，还额外有CAS的操作。在有竞争的情况下，轻量级锁效率更低，所以锁的优化也是分场景

6. 偏向锁（Biased Locking, 可通过-XX:+UseBiasedLocking开启）: 偏向锁是在无锁竞争的情况下，直接消除锁同步原语，进一步提高程序性能。如果说轻量级锁在无锁竞争的情况下是采用CAS的话，那么偏向锁直接CAS的操作都省掉了。
偏向锁偏向于第一个获取到对象锁的线程，如果在执行过程中，没有其他的线程来竞争，那么持有偏向锁的线程永远不需要同步。当锁对象第一次获取是，对象的Mark Word字段会被设置为"01",同时采用CAS的方式把获取到锁的线程ID记录到Mark Word，当持有偏向锁的线程再进入时，
虚拟机不会进行任何同步操作。
当有另外一个线程尝试获取锁时候，偏向模式宣告失败。根据锁对象目前是否处于被锁定的状态，撤销偏向后恢复到未锁定"01"或轻量级锁"00"的状态，后续的同步操作与轻量级一样执行。

适用于单线程同步操作场景

## JVM 讲解

参考: https://blog.csdn.net/qq_41701956/article/details/81664921